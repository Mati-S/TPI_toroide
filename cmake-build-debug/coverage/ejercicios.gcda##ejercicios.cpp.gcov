        -:    0:Source:/cygdrive/c/Users/vAsmad/CLionProjects/Algoritmos-y-Estructura-de-Datos-1/TPS/Trabajo Implementacion/ejercicios.cpp
        -:    0:Graph:/cygdrive/c/Users/vAsmad/CLionProjects/Algoritmos-y-Estructura-de-Datos-1/TPS/Trabajo Implementacion/cmake-build-debug/CMakeFiles/juegoDeLaVida.dir/ejercicios.gcno
        -:    0:Data:/cygdrive/c/Users/vAsmad/CLionProjects/Algoritmos-y-Estructura-de-Datos-1/TPS/Trabajo Implementacion/cmake-build-debug/CMakeFiles/juegoDeLaVida.dir/ejercicios.gcda
        -:    0:Runs:1
        -:    1:#include <algorithm>
        -:    2:#include "ejercicios.h"
        -:    3:#include "auxiliares.h"
        -:    4:#include "iostream"
        -:    5:
        -:    6:// EJERCICIO 1
        3:    7:bool toroideValido(vector<vector<bool>> const &t) {
        3:    8:    return esToroide(t);
        3:    8-block  0
        -:    9:}
        -:   10:
        -:   11:// EJERCICIO 2
       34:   12:bool toroideMuerto(toroide const &t) {
       34:   13:    bool resp = true;
      171:   14:    for(int i = 0; i<t.size(); i++){
       34:   14-block  0
      171:   14-block  1
      137:   14-block  2
      608:   15:        for(int j = 0; j<t[i].size(); j++){
      137:   15-block  0
      608:   15-block  1
      471:   15-block  2
      471:   16:            if(t[i][j]){
      471:   16-block  0
       85:   17:                resp = false;
       85:   17-block  0
        -:   18:            }
        -:   19:        }
        -:   20:    }
       34:   21:    return resp;
       34:   21-block  0
        -:   22:}
        -:   23:
        -:   24:// EJERCICIO 3
        1:   25:vector<posicion> posicionesVivas(toroide const &t) {
        1:   26:	vector<posicion> vivos;
        1:   26-block  0
        7:   27:    for(int i = 0; i<t.size(); i++){
        7:   27-block  0
        6:   27-block  1
       24:   28:        for(int j = 0; j<t[0].size(); j++){
        6:   28-block  0
       24:   28-block  1
       18:   28-block  2
       18:   29:            if(t[i][j]){
       18:   29-block  0
        6:   30:                vivos.push_back(mp(i,j));
        6:   30-block  0
        6:   30-block  1
        6:   30-block  2
    $$$$$:   30-block  3
        -:   31:            }
        -:   32:        }
        -:   33:    }
        1:   34:    return vivos;
        1:   34-block  0
        1:   34-block  1
        -:   35:}
        -:   36:
        -:   37:// EJERCICIO 4
        1:   38:float densidadPoblacion(toroide const &t) {
        1:   39:	float resp = 0;
        1:   40:	float c = cantidadVivas(t);
        1:   40-block  0
        1:   40-block  1
    $$$$$:   40-block  2
        1:   41:	float sT = superficieTotal(t);
        1:   42:	resp = c/sT;
        1:   43:    return resp;
        1:   43-block  0
        -:   44:}
        -:   45:
        -:   46:// EJERCICIO 5
        1:   47:int cantidadVecinosVivos(toroide const &t, int f, int c) {
        1:   48:    int resp = vecinosVivos(t, f, c);
        1:   48-block  0
        1:   49:    return resp;
        -:   50:}
        -:   51:
        -:   52:// EJERCICIO 6
      470:   53:bool evolucionDePosicion(toroide const &t, posicion x) {
      470:   54:	bool resp = debeVivir(t, x.first, x.second);
      470:   54-block  0
      470:   54-block  1
    $$$$$:   54-block  2
      470:   55:    return resp;
      470:   55-block  0
        -:   56:}
        -:   57:
        -:   58:// EJERCICIO 7
       28:   59:void evolucionToroide(toroide &t){
       56:   60:    toroide tEvo = t;
       28:   60-block  0
       28:   60-block  1
    $$$$$:   60-block  2
      144:   61:    for(int i = 0; i<t.size(); i++){
       28:   61-block  0
      144:   61-block  1
      116:   61-block  2
      584:   62:        for(int j = 0; j<t[i].size(); j++){
      116:   62-block  0
      584:   62-block  1
      468:   63:            t[i][j] = evolucionDePosicion(tEvo, mp(i,j));
      468:   63-block  0
      468:   63-block  1
      468:   63-block  2
        -:   64:        }
        -:   65:    }
       28:   66:}
        -:   67:
        -:   68:// EJERCICIO 8
        1:   69:toroide evolucionMultiple(toroide const &t, int k) {
        1:   70:    toroide out = t;
        1:   70-block  0
        1:   71:    int i = 1;
        2:   72:    while(i<=k){
        2:   72-block  0
        1:   73:        evolucionToroide(out);
        1:   73-block  0
        1:   74:        i++;
        1:   74-block  0
        -:   75:    }
        1:   76:    return out;
        1:   76-block  0
        1:   76-block  1
        -:   77:}
        -:   78:
        -:   79:// EJERCICIO 9
        7:   80:bool esPeriodico(toroide const &t, int &p) {
        7:   81:    bool resp = false;
        7:   82:    toroide tEvo = t;
        7:   82-block  0
    $$$$$:   82-block  1
        7:   83:    int i = 1;
        7:   84:    evolucionToroide(tEvo);
        7:   84-block  0
       12:   85:    while(tEvo != t && !toroideMuerto(tEvo)){
       12:   85-block  0
       12:   85-block  1
       10:   85-block  2
       10:   85-block  3
        5:   85-block  4
        7:   85-block  5
       12:   85-block  6
        5:   86:        evolucionToroide(tEvo);
        5:   86-block  0
        5:   87:        i++;
        5:   87-block  0
        -:   88:    }
        7:   89:    if(!toroideMuerto(tEvo)){
        7:   89-block  0
        7:   89-block  1
        2:   90:        resp = true;
        2:   90-block  0
        -:   91:    }else{
        5:   92:        i = 0;
        5:   92-block  0
        -:   93:    }
        7:   94:    p = i;
       14:   95:    return resp;
        7:   95-block  0
        7:   95-block  1
        -:   96:}
        -:   97:
        -:   98:// EJERCICIO 10
        2:   99:bool primosLejanos(toroide const &t, toroide const &u) {
        2:  100:	bool resp = false; 
        4:  101:    toroide tEvo = t;
        2:  101-block  0
    $$$$$:  101-block  1
        2:  102:    toroide uEvo = u;
        2:  102-block  0
    $$$$$:  102-block  1
        2:  103:    evolucionToroide(tEvo);
        2:  103-block  0
        2:  104:    evolucionToroide(uEvo);
        2:  104-block  0
        4:  105:    while(tEvo != t || uEvo != u){
        4:  105-block  0
        4:  105-block  1
        2:  105-block  2
        2:  105-block  3
        2:  105-block  4
        2:  105-block  5
        4:  105-block  6
        2:  105-block  7
        2:  106:        evolucionToroide(tEvo);
        2:  106-block  0
        2:  107:        evolucionToroide(uEvo);
        2:  107-block  0
        -:  108:    }
       2*:  109:    if(tEvo == t || uEvo == u){
        2:  109-block  0
        2:  109-block  1
    %%%%%:  109-block  2
    %%%%%:  109-block  3
        2:  109-block  4
    %%%%%:  109-block  5
        2:  109-block  6
        2:  110:        resp = true;
        2:  110-block  0
        -:  111:    }
        4:  112:    return resp;
        2:  112-block  0
        2:  112-block  1
        -:  113:}
        -:  114:
        -:  115:// EJERCICIO 11
        2:  116:int seleccionNatural(vector<toroide> ts) {
        2:  117:    int resp = -1;
        2:  118:    int muertIn = 0;
        2:  119:    int muertFin = 0;
        2:  120:    bool hayUnPeriodico = false;
        7:  121:	for(int i = 0; i<ts.size() && !hayUnPeriodico;i++){
        2:  121-block  0
        7:  121-block  1
        6:  121-block  2
        5:  121-block  3
        2:  121-block  4
        7:  121-block  5
       10:  122:	    toroide t = ts[i];
        5:  122-block  0
        5:  122-block  1
    $$$$$:  122-block  2
        5:  123:        if(!toroideMuerto(t)){
        5:  123-block  0
        5:  123-block  1
        -:  124:            int dead;
        5:  125:            bool estaMuerto = toroideMuerto(t);
        5:  125-block  0
        5:  126:            bool esPeriod = esPeriodico(t, dead);
        5:  126-block  0
        5:  127:            if(!esPeriod){
        5:  127-block  0
       10:  128:                while(!estaMuerto){
       10:  128-block  0
        6:  129:                    evolucionToroide(t);
        6:  129-block  0
        6:  130:                    if(toroideMuerto(t)){
        6:  130-block  0
        6:  130-block  1
        4:  131:                        estaMuerto = true;
        4:  131-block  0
        -:  132:                    }
        6:  133:                    muertFin++;
        6:  133-block  0
        -:  134:                }
        4:  135:                if(muertFin > muertIn){
        4:  135-block  0
        2:  136:                    muertIn = muertFin;
        2:  137:                    resp = i;
        2:  138:                    muertFin = 0;
        2:  138-block  0
        -:  139:                }
        -:  140:            }else{
        1:  141:                resp = i;
        1:  142:                hayUnPeriodico = true;
        1:  142-block  0
        -:  143:            }
        -:  144:        }
        -:  145:	}
        2:  146:    return resp;
        2:  146-block  0
        2:  146-block  1
        -:  147:}
        -:  148:
        -:  149:// EJERCICIO 12
        1:  150:toroide fusionar(toroide const &t, toroide const &u) {
        2:  151:    toroide out(t.size(), vector<bool>(t[0].size(), false));
        1:  151-block  0
        1:  151-block  1
    $$$$$:  151-block  2
    $$$$$:  151-block  3
        4:  152:    for(int i = 0; i<t.size(); i++){
        4:  152-block  0
        3:  152-block  1
       12:  153:        for(int j = 0; j<t[i].size(); j++){
        3:  153-block  0
       12:  153-block  1
        9:  153-block  2
       9*:  154:            if(t[i][j] && u[i][j]){
        9:  154-block  0
        3:  154-block  1
    %%%%%:  154-block  2
        9:  154-block  3
        9:  154-block  4
    #####:  155:                out[i][j] = true;
    %%%%%:  155-block  0
        -:  156:            }
        -:  157:        }
        -:  158:    }
        1:  159:    return out;
        1:  159-block  0
        1:  159-block  1
        -:  160:}
        -:  161:
        -:  162:// EJERCICIO 13
        2:  163:bool vistaTrasladada(toroide const &t, toroide const &u){
        2:  164:    toroide tTraslado = t;
        2:  164-block  0
    $$$$$:  164-block  1
        2:  165:	bool resp = false;
        2:  166:    int x = 0;
        2:  166-block  0
        8:  167:    while(x < t.size()){
        8:  167-block  0
        6:  168:        int y = 0;
        6:  168-block  0
       24:  169:        while(y < t[0].size()){
       24:  169-block  0
       18:  170:            if(!resp){
       18:  170-block  0
       12:  171:                tTraslado = trasladarToroide(t, x, y);
       12:  171-block  0
       12:  171-block  1
       12:  171-block  2
    $$$$$:  171-block  3
    $$$$$:  171-block  4
       12:  172:                if(tTraslado == u){
       12:  172-block  0
        1:  173:                    resp = true;
        1:  173-block  0
        -:  174:                }
        -:  175:            }
       18:  176:            y++;
       18:  176-block  0
        -:  177:        }
        6:  178:        x++;
        6:  178-block  0
        -:  179:    }
        4:  180:    return resp;
        2:  180-block  0
        2:  180-block  1
        -:  181:}
        -:  182:
        -:  183:// EJERCICIO 14
        2:  184:int menorSuperficieViva(toroide const &t){
        2:  185:	int resp = -1;
        2:  186:	const toroide& tTraslado = t;
        2:  187:	vector<toroide> toroideLista;
        2:  187-block  0
    $$$$$:  187-block  1
       12:  188:    for(int i = 0; i<t.size(); i++){
       12:  188-block  0
       10:  188-block  1
       74:  189:        for(int j = 0; j<t[i].size();j++){
       10:  189-block  0
       74:  189-block  1
       64:  190:            toroideLista.push_back(trasladarToroide(tTraslado, i, j));
       64:  190-block  0
       64:  190-block  1
       64:  190-block  2
       64:  190-block  3
    $$$$$:  190-block  4
    $$$$$:  190-block  5
    $$$$$:  190-block  6
    $$$$$:  190-block  7
        -:  191:        }
        -:  192:    }
        2:  193:    int f= filas(t);
        2:  193-block  0
        2:  194:    int c = columnas(t);
        2:  194-block  0
        2:  194-block  1
        2:  194-block  2
    $$$$$:  194-block  3
    $$$$$:  194-block  4
        2:  195:    int superficieMasChica = f * c;
        -:  196:
       66:  197:    for(int i = 0; i<toroideLista.size(); i++){
       66:  197-block  0
       64:  197-block  1
       64:  198:        int superficie = superficieVivas(toroideLista[i]);
       64:  198-block  0
       64:  198-block  1
       64:  198-block  2
    $$$$$:  198-block  3
    $$$$$:  198-block  4
       64:  199:        if(superficie < superficieMasChica){
        4:  200:            superficieMasChica = superficie;
        4:  200-block  0
        -:  201:        }
        -:  202:    }
        -:  203:
        2:  204:    resp = superficieMasChica;
        2:  205:    cout << resp << endl;
        2:  205-block  0
        2:  205-block  1
        4:  206:	return resp;
        2:  206-block  0
        2:  206-block  1
        -:  207:}
