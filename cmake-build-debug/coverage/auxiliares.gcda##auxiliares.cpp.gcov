        -:    0:Source:/cygdrive/c/Users/vAsmad/CLionProjects/Algoritmos-y-Estructura-de-Datos-1/TPS/Trabajo Implementacion/auxiliares.cpp
        -:    0:Graph:/cygdrive/c/Users/vAsmad/CLionProjects/Algoritmos-y-Estructura-de-Datos-1/TPS/Trabajo Implementacion/cmake-build-debug/CMakeFiles/juegoDeLaVida.dir/auxiliares.gcno
        -:    0:Data:/cygdrive/c/Users/vAsmad/CLionProjects/Algoritmos-y-Estructura-de-Datos-1/TPS/Trabajo Implementacion/cmake-build-debug/CMakeFiles/juegoDeLaVida.dir/auxiliares.gcda
        -:    0:Runs:1
        -:    1:#include "definiciones.h"
        -:    2:#include "auxiliares.h"
        -:    3:
        -:    4:using namespace std;
        -:    5:// aqui se pueden ubicar todas las funciones auxiliares de soporte para la resolucion de los ejercicios
      480:    6:pair<int,int> mp(int a, int b) {
      480:    7:    return make_pair(a, b);
      480:    7-block  0
        -:    8:}
        -:    9:
     8504:   10:int mod (int a, int b){
     8504:   11:    if(b < 0) //you can check for b == 0 separately and do what you want
     8504:   11-block  0
    #####:   12:        return -mod(-a, -b);
    %%%%%:   12-block  0
     8504:   13:    int ret = a % b;
     8504:   14:    if(ret < 0)
     8504:   14-block  0
      678:   15:        ret+=b;
      678:   15-block  0
     8504:   16:    return ret;
     8504:   16-block  0
        -:   17:}
        -:   18:
     7549:   19:int filas(const rectangulo& t){
     7549:   20:    return t.size();
     7549:   20-block  0
        -:   21:}
        -:   22:
     3774:   23:int columnas(rectangulo t) {
     3774:   24:    int f = 0;
     3774:   25:    if (filas(t) > 0) {
     3774:   25-block  0
     3774:   26:        f = t[0].size();
     3774:   26-block  0
        -:   27:    }
     3774:   28:    return f;
     3774:   28-block  0
        -:   29:}
        -:   30:
        1:   31:bool esRectangulo(rectangulo r){
        1:   32:    bool iguales = true;
       1*:   33:    if(filas(r)>0 && columnas(r) > 0){
        1:   33-block  0
        1:   33-block  1
        1:   33-block  2
        1:   33-block  3
    %%%%%:   33-block  4
        1:   33-block  5
        1:   33-block  6
        1:   33-block  7
    $$$$$:   33-block  8
    $$$$$:   33-block  9
        4:   34:        for(int i = 0; i<r.size(); i++){
        1:   34-block  0
        4:   34-block  1
        3:   34-block  2
        3:   35:            if(r[i].size() != r[0].size()){
        3:   35-block  0
    #####:   36:                iguales=false;
    %%%%%:   36-block  0
        -:   37:            }
        -:   38:        }
        -:   39:    }
        1:   40:    return iguales;
        1:   40-block  0
        1:   40-block  1
        -:   41:}
        -:   42:
        3:   43:bool esToroide(const toroide& t){
        3:   44:    bool resp = false;
        3:   45:    if(filas(t) >= 3 && columnas(t) >= 3 && esRectangulo(t)){
        3:   45-block  0
        2:   45-block  1
        2:   45-block  2
        1:   45-block  3
        1:   45-block  4
        1:   45-block  5
        1:   45-block  6
        2:   45-block  7
        3:   45-block  8
        1:   45-block  9
        3:   45-block 10
        2:   45-block 11
        3:   45-block 12
    $$$$$:   45-block 13
    $$$$$:   45-block 14
    $$$$$:   45-block 15
    $$$$$:   45-block 16
    $$$$$:   45-block 17
        1:   46:        resp = true;
        1:   46-block  0
        -:   47:    }
        3:   48:    return resp;
        3:   48-block  0
        3:   48-block  1
        -:   49:}
        -:   50:
        1:   51:float cantidadVivas(toroide t){
        1:   52:    float vivas = 0 ;
        6:   53:    for(int i = 0; i<t.size(); i++){
        1:   53-block  0
        6:   53-block  1
        5:   53-block  2
       25:   54:        for(int j = 0; j<t[0].size(); j++){
        5:   54-block  0
       25:   54-block  1
       20:   54-block  2
       20:   55:            if(t[i][j]){
       20:   55-block  0
       20:   56:                vivas++;
       20:   56-block  0
        -:   57:            }
        -:   58:        }
        -:   59:    }
        1:   60:    return vivas;
        1:   60-block  0
        -:   61:}
        -:   62:
        1:   63:float superficieTotal(const toroide& t){
        1:   64:    return (filas(t) * columnas(t));
        1:   64-block  0
        -:   65:}
        -:   66:
     3768:   67:int filaToroide(int f, toroide t){
     3768:   68:    return mod(f, filas(t));
     3768:   68-block  0
        -:   69:}
        -:   70:
     3768:   71:int columnaToroide(int c, toroide t){
     3768:   72:    return mod(c, columnas(t));
     3768:   72-block  0
     3768:   72-block  1
     3768:   72-block  2
     3768:   72-block  3
    $$$$$:   72-block  4
        -:   73:}
        -:   74:
      471:   75:int vecinosVivos(const toroide& t, int f, int c){
      471:   76:    int vivos = 0;
        -:   77:
     1884:   78:    for(int i = f-1; i<=f+1; i++){
      471:   78-block  0
     1884:   78-block  1
     1413:   78-block  2
     5652:   79:        for(int j = c-1; j<= c+1; j++){
     1413:   79-block  0
     5652:   79-block  1
     4239:   79-block  2
     4239:   80:            if((i != f) || (j != c)){
     4239:   80-block  0
     1413:   80-block  1
     3768:   81:                int x = filaToroide(i, t);
     3768:   81-block  0
     3768:   81-block  1
    $$$$$:   81-block  2
    $$$$$:   81-block  3
     3768:   82:                int y = columnaToroide(j, t);
     3768:   82-block  0
    $$$$$:   82-block  1
     3768:   83:                if(t[x][y]){
      861:   84:                    vivos++;
      861:   84-block  0
        -:   85:                }
        -:   86:            }
        -:   87:        }
        -:   88:    }
        -:   89:
      471:   90:    return vivos;
      471:   90-block  0
      471:   90-block  1
        -:   91:}
        -:   92:
      470:   93:bool debeVivir(toroide t, int x, int y){
      470:   94:    bool resp = false;
      470:   95:    int cantVivos = vecinosVivos(t, x, y);
      470:   95-block  0
      470:   96:    if(t[x][y] && cantVivos >= 2 && cantVivos <= 3){
      107:   96-block  0
       79:   96-block  1
       34:   96-block  2
      436:   96-block  3
      470:   96-block  4
       34:   97:        resp = true;
       34:   97-block  0
      436:   98:    }else if(!t[x][y] && cantVivos == 3){
      436:   98-block  0
      363:   98-block  1
       66:   98-block  2
      370:   98-block  3
      436:   98-block  4
       66:   99:        resp = true;
       66:   99-block  0
        -:  100:    }
      470:  101:    return resp;
      470:  101-block  0
        -:  102:}
        -:  103:
       76:  104:toroide trasladarToroide(toroide t, int x, int y){
      152:  105:    toroide tTraslado(t.size(), vector<bool>(t[0].size(), false));
       76:  105-block  0
       76:  105-block  1
    $$$$$:  105-block  2
    $$$$$:  105-block  3
      464:  106:    for(int i = 0; i < t.size(); i++){
      464:  106-block  0
      388:  106-block  1
     3056:  107:        for(int j = 0; j < t[i].size(); j++){
      388:  107-block  0
     3056:  107-block  1
     2668:  107-block  2
     2668:  108:            if(t[i][j]){
     2668:  108-block  0
      484:  109:                tTraslado[mod(i+x, t.size())][mod(j+y, t[i].size())] = t[i][j];
      484:  109-block  0
      484:  109-block  1
      484:  109-block  2
    $$$$$:  109-block  3
        -:  110:            }
        -:  111:        }
        -:  112:    }
       76:  113:    return tTraslado;
       76:  113-block  0
       76:  113-block  1
        -:  114:}
        -:  115:
       64:  116:int superficieVivas(toroide t){
       64:  117:    int lejosX = 0;
       64:  118:    int lejosY = 0;
       64:  119:    int cercaX = t.size();
       64:  119-block  0
       64:  120:    int cercaY = t[0].size();
        -:  121:
      416:  122:    for(int i = 0; i<t.size(); i++){
      416:  122-block  0
      352:  122-block  1
     2912:  123:        for(int j = 0; j<t[i].size(); j++){
      352:  123-block  0
     2912:  123-block  1
     2560:  123-block  2
     2560:  124:            if(t[i][j]){
     2560:  124-block  0
      448:  125:                if(cercaX > i){
      448:  125-block  0
       64:  126:                    cercaX = i;
       64:  126-block  0
        -:  127:                }
      448:  128:                if(cercaY > j){
      448:  128-block  0
       92:  129:                    cercaY = j;
       92:  129-block  0
        -:  130:                }
      448:  131:                if(i > lejosX){
      448:  131-block  0
      144:  132:                    lejosX = i;
      144:  132-block  0
        -:  133:                }
      448:  134:                if(j > lejosY){
      448:  134-block  0
      233:  135:                    lejosY = j;
      233:  135-block  0
        -:  136:                }
        -:  137:            }
        -:  138:        }
        -:  139:    }
       64:  140:    int superficieX = lejosX - cercaX + 1;
       64:  141:    int superficieY = lejosY - cercaY + 1;
       64:  142:    return (superficieX*superficieY);
       64:  142-block  0
        -:  143:
        -:  144:}
        -:  145:
        -:  146://No pueden usar esta función para resolver el TPI.
        -:  147://Tampoco pueden usar iteradores, como usa esta función.
        2:  148:vector<posicion> ordenar(vector<posicion> &v) {
        2:  149:    sort(v.begin(), v.end());
        2:  149-block  0
        2:  150:    return v;
        -:  151:}
